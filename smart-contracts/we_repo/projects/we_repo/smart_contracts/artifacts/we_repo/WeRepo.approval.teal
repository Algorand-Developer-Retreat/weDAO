#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 10 8
    bytecblock "total_projects" "_p" "pong"
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txn NumAppArgs
    bz main_after_if_else@10
    pushbytess 0xb8447b36 0x855341c5 0xeb03c927 0x40bbd405 // method "createApplication()void", method "ping(string)void", method "createNewProject(string,string)void", method "addNewDappsToProject(uint64[],account)void"
    txna ApplicationArgs 0
    match main_createApplication_route@3 main_ping_route@4 main_createNewProject_route@5 main_addNewDappsToProject_route@6

main_after_if_else@10:
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    intc_0 // 0
    return

main_addNewDappsToProject_route@6:
    // smart_contracts/we_repo/contract.algo.ts:61
    // public addNewDappsToProject(dappIds: uint64[], creatorAddress: Account): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    txnas Accounts
    // smart_contracts/we_repo/contract.algo.ts:61
    // public addNewDappsToProject(dappIds: uint64[], creatorAddress: Account): void {
    callsub addNewDappsToProject
    intc_1 // 1
    return

main_createNewProject_route@5:
    // smart_contracts/we_repo/contract.algo.ts:40
    // public createNewProject(projectName: string, projectDescription: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    txna ApplicationArgs 2
    extract 2 0
    // smart_contracts/we_repo/contract.algo.ts:40
    // public createNewProject(projectName: string, projectDescription: string): void {
    callsub createNewProject
    intc_1 // 1
    return

main_ping_route@4:
    // smart_contracts/we_repo/contract.algo.ts:36
    // public ping(ping: string): void {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/we_repo/contract.algo.ts:17
    // export class WeRepo extends Contract {
    txna ApplicationArgs 1
    extract 2 0
    // smart_contracts/we_repo/contract.algo.ts:36
    // public ping(ping: string): void {
    callsub ping
    intc_1 // 1
    return

main_createApplication_route@3:
    // smart_contracts/we_repo/contract.algo.ts:27
    // @abimethod({ allowActions: 'NoOp', onCreate: 'require' })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    callsub createApplication
    intc_1 // 1
    return


// smart_contracts/we_repo/contract.algo.ts::WeRepo.createApplication() -> void:
createApplication:
    // smart_contracts/we_repo/contract.algo.ts:19
    // manager_address = GlobalState<Account>()
    pushbytes "manager_address"
    // smart_contracts/we_repo/contract.algo.ts:29
    // this.manager_address.value = Txn.sender
    txn Sender
    app_global_put
    // smart_contracts/we_repo/contract.algo.ts:20
    // total_projects = GlobalState<uint64>()
    bytec_0 // "total_projects"
    // smart_contracts/we_repo/contract.algo.ts:30
    // this.total_projects.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/we_repo/contract.algo.ts:21
    // total_reputation = GlobalState<uint64>()
    pushbytes "total_reputation"
    // smart_contracts/we_repo/contract.algo.ts:31
    // this.total_reputation.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/we_repo/contract.algo.ts:22
    // total_contribution = GlobalState<uint64>()
    pushbytes "total_contribution"
    // smart_contracts/we_repo/contract.algo.ts:32
    // this.total_contribution.value = 0
    intc_0 // 0
    app_global_put
    // smart_contracts/we_repo/contract.algo.ts:23
    // pong = GlobalState<string>()
    bytec_2 // "pong"
    // smart_contracts/we_repo/contract.algo.ts:33
    // this.pong.value = ''
    pushbytes ""
    app_global_put
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.ping(ping: bytes) -> void:
ping:
    // smart_contracts/we_repo/contract.algo.ts:36
    // public ping(ping: string): void {
    proto 1 0
    // smart_contracts/we_repo/contract.algo.ts:23
    // pong = GlobalState<string>()
    bytec_2 // "pong"
    // smart_contracts/we_repo/contract.algo.ts:37
    // this.pong.value = ping
    frame_dig -1
    app_global_put
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.createNewProject(projectName: bytes, projectDescription: bytes) -> void:
createNewProject:
    // smart_contracts/we_repo/contract.algo.ts:40
    // public createNewProject(projectName: string, projectDescription: string): void {
    proto 2 0
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectIdType, ProjectDataType>({ keyPrefix: '_p' })
    bytec_1 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:41
    // const creatorAddress: Account = Txn.sender
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectIdType, ProjectDataType>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:47
    // assert(!currentProjectInstance.exists, 'Project already exists for this address')
    dup
    box_len
    bury 1
    !
    assert // Project already exists for this address
    // smart_contracts/we_repo/contract.algo.ts:51
    // project_name_and_description: new arc4.Str(`${projectName};${projectDescription}`),
    frame_dig -2
    pushbytes ";"
    concat
    frame_dig -1
    concat
    dup
    len
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/we_repo/contract.algo.ts:50-54
    // const project: ProjectDataType = new ProjectDataType({
    //   project_name_and_description: new arc4.Str(`${projectName};${projectDescription}`),
    //   project_contribution: new arc4.UintN64(0),
    //   project_dapps: new arc4.DynamicArray<arc4.UintN64>(),
    // })
    pushbytes 0x0000000000000000000c000e0000
    swap
    concat
    // smart_contracts/we_repo/contract.algo.ts:20
    // total_projects = GlobalState<uint64>()
    intc_0 // 0
    bytec_0 // "total_projects"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/we_repo/contract.algo.ts:56
    // this.total_projects.value = Uint64(this.total_projects.value + 1)
    intc_1 // 1
    +
    // smart_contracts/we_repo/contract.algo.ts:20
    // total_projects = GlobalState<uint64>()
    bytec_0 // "total_projects"
    // smart_contracts/we_repo/contract.algo.ts:56
    // this.total_projects.value = Uint64(this.total_projects.value + 1)
    swap
    app_global_put
    // smart_contracts/we_repo/contract.algo.ts:58
    // this.project(new arc4.Address(creatorAddress)).value = project.copy()
    dig 1
    box_del
    pop
    box_put
    retsub


// smart_contracts/we_repo/contract.algo.ts::WeRepo.addNewDappsToProject(dappIds: bytes, creatorAddress: bytes) -> void:
addNewDappsToProject:
    // smart_contracts/we_repo/contract.algo.ts:61
    // public addNewDappsToProject(dappIds: uint64[], creatorAddress: Account): void {
    proto 2 0
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectIdType, ProjectDataType>({ keyPrefix: '_p' })
    bytec_1 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:62
    // const currentProjectInstance = this.project(new arc4.Address(creatorAddress))
    frame_dig -1
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectIdType, ProjectDataType>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:65
    // assert(currentProjectInstance.exists, 'Project does not exist for this address')
    dup
    box_len
    bury 1
    assert // Project does not exist for this address
    // smart_contracts/we_repo/contract.algo.ts:69
    // project_name_and_description: currentProjectInstance.value.project_name_and_description,
    dup
    box_get
    assert // Box must have value
    dup
    intc_2 // 10
    extract_uint16
    dig 1
    len
    substring3
    // smart_contracts/we_repo/contract.algo.ts:70
    // project_contribution: currentProjectInstance.value.project_contribution,
    dig 1
    box_get
    assert // Box must have value
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/we_repo/contract.algo.ts:71
    // project_dapps: currentProjectInstance.value.project_dapps.copy(), // Add .copy() here
    uncover 2
    box_get
    assert // Box must have value
    dup
    intc_3 // 8
    extract_uint16
    dig 1
    intc_2 // 10
    extract_uint16
    substring3
    // smart_contracts/we_repo/contract.algo.ts:68-72
    // const project: ProjectDataType = new ProjectDataType({
    //   project_name_and_description: currentProjectInstance.value.project_name_and_description,
    //   project_contribution: currentProjectInstance.value.project_contribution,
    //   project_dapps: currentProjectInstance.value.project_dapps.copy(), // Add .copy() here
    // })
    swap
    pushbytes 0x000c
    concat
    dig 1
    len
    pushint 12 // 12
    +
    itob
    extract 6 2
    concat
    swap
    concat
    swap
    concat
    // smart_contracts/we_repo/contract.algo.ts:75
    // for (const dappId of dappIds) {
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_0 // 0

addNewDappsToProject_for_header@1:
    // smart_contracts/we_repo/contract.algo.ts:75
    // for (const dappId of dappIds) {
    frame_dig 2
    frame_dig 1
    <
    bz addNewDappsToProject_after_for@4
    frame_dig -2
    extract 2 0
    frame_dig 2
    dup
    cover 2
    intc_3 // 8
    *
    extract_uint64
    // smart_contracts/we_repo/contract.algo.ts:76
    // project.project_dapps.push(new arc4.UintN64(dappId))
    frame_dig 0
    dup
    intc_3 // 8
    extract_uint16
    dig 1
    intc_2 // 10
    extract_uint16
    dig 2
    dig 2
    dig 2
    substring3
    extract 2 0
    uncover 4
    itob
    concat
    dup
    len
    intc_3 // 8
    /
    itob
    extract 6 2
    swap
    concat
    dig 3
    intc_0 // 0
    dig 4
    extract3
    dig 4
    len
    uncover 5
    dig 4
    uncover 2
    substring3
    swap
    dig 2
    concat
    swap
    concat
    uncover 2
    uncover 3
    -
    uncover 2
    len
    dig 2
    intc_2 // 10
    extract_uint16
    +
    swap
    -
    itob
    extract 6 2
    replace2 10
    frame_bury 0
    intc_1 // 1
    +
    frame_bury 2
    b addNewDappsToProject_for_header@1

addNewDappsToProject_after_for@4:
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectIdType, ProjectDataType>({ keyPrefix: '_p' })
    bytec_1 // "_p"
    // smart_contracts/we_repo/contract.algo.ts:79
    // this.project(new arc4.Address(Txn.sender)).value = project.copy()
    txn Sender
    // smart_contracts/we_repo/contract.algo.ts:25
    // project = BoxMap<ProjectIdType, ProjectDataType>({ keyPrefix: '_p' })
    concat
    // smart_contracts/we_repo/contract.algo.ts:79
    // this.project(new arc4.Address(Txn.sender)).value = project.copy()
    dup
    box_del
    pop
    frame_dig 0
    box_put
    retsub
